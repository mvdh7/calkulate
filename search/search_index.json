{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Calkulate","text":"<p>Calkulate is a Python package for finding total alkalinity [D91] from titration data using PyCO2SYS [HLSP22, HSS22].</p>"},{"location":"#installation","title":"Installation","text":"<pre><code>pip install calkulate\nconda install conda-forge::calkulate\n</code></pre>"},{"location":"#basic-use","title":"Basic use","text":"<p>If the data for each individual titration is in its own text file and you have a spreadsheet containing the metadata for each titration on separate rows \u2014 all formatted as expected \u2014 then all you need to do with Calkulate is:</p> <pre><code>import calkulate as calk\ndata = calk.read_csv(\"path/to/metadata_file.csv\").calkulate()\ndata.alkalinity  # &lt;== here are your alkalinity results\n</code></pre> <p><code>data</code> is then a pandas DataFrame based on the metadata file you provided but with some extra columns added such as <code>data.alkalinity</code>, which contains the fully calibrated total alkalinity for each sample.</p> <p>Other read-in functions are also available (e.g., for Excel spreadsheets and VINDTA .dbs files).</p> <p>See Dataset methods for more information on what <code>calkulate</code> does.</p>"},{"location":"#about","title":"About","text":"<p>Calkulate is being developed primarily by Dr Matthew P. Humphreys at the Royal Netherlands Institute for Sea Research (NIOZ, Texel).</p>"},{"location":"#citation","title":"Citation","text":"<p>If you use Calkulate in your work, please cite it as:</p> <p>Humphreys, M. P. and Matthews, R. S. (2024).  Calkulate: total alkalinity from titration data in Python.  Zenodo. doi:10.5281/zenodo.2634304.</p> <p>Please specify which version you are using.  To find this:</p> <pre><code>import calkulate as calk\ncalk.hello()\n</code></pre>"},{"location":"#license","title":"License","text":"<p>Calkulate is licensed under the GNU General Public License version 3 (GPLv3).</p>"},{"location":"metadata/","title":"The Dataset of titration metadata","text":"<p>A Calkulate <code>Dataset</code> is a pandas DataFrame with some extra methods added.</p> <p>A <code>Dataset</code> can be made from an existing DataFrame or by importing a spreadsheet from various formats.</p> <p>There are some example Dataset spreadsheets in various formats to look at on GitHub.</p> <p>Whichever way it is done, each row of the <code>Dataset</code> corresponds to a separate titration, and each column contains a different piece of metadata.  Some columns are required, others are optional.  The columns must be named as follows.</p>"},{"location":"metadata/#dataset-column-names","title":"Dataset column names","text":"<p>Click on each banner to expand and see more detail.</p> <p>Extra columns will be ignored by Calkulate and should not cause any problems.</p>"},{"location":"metadata/#required-columns","title":"Required columns","text":"<code>file_name</code> : name of the titration file <p>This should include the file extension (e.g. <code>.dat</code>).  The file path can either be included in the file name or be specified separately in a <code>file_path</code> column.</p> <code>salinity</code> : practical salinity of the analyte <p>This is dimensionless.</p> <code>analyte_mass</code> or <code>analyte_volume</code> : mass (kg) or volume (ml) of the analyte <p>Mass must be in kg and volume in ml.</p> <p>If volume is provided, it is converted into mass following MP81.</p> <p>If both are provided for a given titration, mass is used and volume is ignored.</p>"},{"location":"metadata/#recommended-columns","title":"Recommended columns","text":"<p>Not strictly essential, but these will be needed most of the time.  If values are only needed for some titrations, just use <code>np.nan</code> in rows where they are not required.</p> <code>alkalinity_certified</code> : known alkalinity value (e.g. for a reference material) <p>Must be in \u00b5mol/kg-sol.</p> <code>analysis_batch</code> : identifies subsets that can be calibrated together <p>A list of analysis batch names or numbers.  It is assumed that all titrations with the same <code>analysis_batch</code> value have a common titrant.  If nothing is provided, all titrations are assumed to have a common titrant.</p> <code>dic</code> : dissolved inorganic carbon (\u00b5mol/kg-sol) <p>In \u00b5mol/kg-sol.</p> <p>Defaults to zero if not provided.</p> <code>file_path</code> : path to the titration file <p>This is prefixed to <code>file_name</code>.</p> <code>total_*</code> : total salt concentrations (\u00b5mol/kg-sol) <p>These must all be in \u00b5mol/kg-sol.</p> <p>Some default to zero if not provided:</p> <ul> <li><code>total_ammonia</code> : total ammonia + ammonium</li> <li><code>total_phosphate</code> : total phosphate</li> <li><code>total_silicate</code> : total silicate</li> <li><code>total_sulfide</code> : total hydrogen sulfide</li> </ul> <p>Others are estimated from salinity by PyCO2SYS if not provided:</p> <ul> <li><code>total_borate</code> : total borate</li> <li><code>total_fluoride</code> : total fluoride</li> <li><code>total_sulfate</code> : total sulfate</li> </ul>"},{"location":"metadata/#optional-columns","title":"Optional columns","text":"<p>Like for the recommended columns, if optional column values are only needed for some titrations.  Just use <code>np.nan</code> in rows where they are not required.</p> <code>dilute_totals_for_ks</code> : account for dilution when calculating equilibrium constants? <p>If <code>False</code> (default if not provided), then don't account for dilution of total sulfate and fluoride when calculating equilibrium constants.</p> <p>Introduced in v23.7 - in earlier versions, default behaviour was like <code>dilute_totals_for_ks=True</code>.</p> <code>double</code> : solve twice to improve pH range? <p>If <code>True</code> (default if not provided), then solve each titration twice, using the EMF<sup>0</sup> from the first solution as the start-point for the second.  This means that the set of data points used more accurately matches the pH range specified by <code>pH_min</code> and <code>pH_max</code>.</p> <p>Introduced in v23.7 - in earler versions, default behaviour was like <code>double=False</code>.</p> <code>file_good</code> : is the titration file valid? <p>Where set to <code>False</code>, Calkulate does not attempt to import the corresponding titration file.</p> <code>file_type</code> : which file format are your titration data in? <p>Indicates the format of the titration data file:</p> <ul> <li><code>\"genfromtxt\"</code> : the default VINDTA-style format, or</li> <li><code>\"pclims\"</code> : PC-LIMS report files generated by e.g. a Metrohm Titrino unit.</li> <li><code>\"tiamo_de\"</code> : files from German-language Tiamo software.</li> </ul> <p>Alias for <code>read_dat_method</code>, added in v23.7.</p> <code>gran_logic</code> : which points to use for Gran-plot estimates <p>Prior to v23.7, Gran-plot initial estimates of alkalinity and EMF<sup>0</sup> were determined using data points that were above 10% and below 90% of the maximum value of the Gran function.  From v23.7, the 90% upper cutoff was removed.</p> <ul> <li><code>\"v23.7+\"</code> : use the new behaviour without upper cutoff (default).</li> <li><code>\"legacy\"</code> : use the original approach with upper and lower cutoffs.</li> </ul> <code>k_*</code> : stoichiometric equilibrium constants <p>If not provided, then these are calculated from temperature and salinity by PyCO2SYS.</p> <p>They must all be on the Free pH scale.</p> <ul> <li><code>k_borate</code> : boric acid equilibrium constant.</li> <li><code>k_carbonic_1</code> and <code>k_carbonic_2</code> : carbonic acid dissociation constants.</li> <li><code>k_fluoride</code> : HF equilibrium constant.</li> <li><code>k_phosphoric_1</code>, <code>k_phosphoric_2</code> and <code>k_phosphoric_3</code> : phosphoric acic dissociation constants.</li> <li><code>k_silicate</code> : orthosilicic acid equilibrium constant.</li> <li><code>k_sulfide</code> : hydrogen sulfide equilibrium constant.</li> <li><code>k_bisulfate</code> : bisulfate dissociation constant.</li> <li><code>k_water</code> : water equilibrium constant.</li> </ul> <code>molinity_HCl</code> : approximate HCl molinity in the HCl titrant <p>In mol/kg-sol.  Defaults to 0.1 mol/kg-sol if not provided.  Used only to estimate titrant density, not for calibration.</p> <code>molinity_NaCl</code> : approximate NaCl molinity in the HCl titrant <p>In mol/kg-sol.  Defaults to 0.6 mol/kg-sol if not provided.  Used only to estimate titrant density.</p> <code>molinity_H2SO4</code> : approximate NaCl molinity in the H<sub>2</sub>SO<sub>4</sub> titrant <p>In mol/kg-sol.  Defaults to 0.1 mol/kg-sol if not provided.  Used only to estimate titrant density, not for calibration.</p> <code>opt_k_bisulfate</code> : which bisulfate dissociation constant to use <p>Sets whether the bisulfate dissociation constant is estimated from salinity and temperature by PyCO2SYS following:</p> <ul> <li><code>1</code> : D90a (default), or</li> <li><code>2</code> : KRCB77.</li> </ul> <code>opt_k_carbonic</code> : which carbonic acid dissociation constants to use <p>Sets which carbonic acid constants to use from PyCO2SYS, can be any integer from <code>1</code> to <code>16</code> inclusive.  Default is <code>16</code> for SLH20.  See the PyCO2SYS docs on <code>opt_k_carbonic</code> for details.</p> <code>opt_k_fluoride</code> : which HF dissociation constant to use <p>Sets whether the HF dissociation constant is estimated from salinity and temperature by PyCO2SYS following:</p> <ul> <li><code>1</code> : DR79 (default), or</li> <li><code>2</code> : PF87.</li> </ul> <code>opt_total_borate</code> : which total borate:salinity relationship to use <p>Sets whether total borate is estimated from salinity by PyCO2SYS following:</p> <ul> <li><code>1</code> : U74 (default), or</li> <li><code>2</code> : LKB10.</li> </ul> <code>pH_min</code> and <code>pH_max</code> : range of pH values to use for solving <p>Specify the range of pH values from the titration to use to calculate the final alkalinity value.</p> <p>Added in v23.7 to replace previous <code>pH_range</code> kwarg.</p> <code>reference_good</code> : use this reference material to calibrate? <p>Set to <code>False</code> for reference materials that you do not wish to include in determining batch-mean titrant concentrations.</p> <code>solve_mode</code> : how to solve for alkalinity <p>The options (which are case-insensitive) are:</p> <ul> <li><code>\"emf\"</code> (default): use least-squares fitting for titration data given in EMF in mV.</li> <li><code>\"pH\"</code>: use least-squares fitting for titration data given in pH.</li> <li><code>\"pH_adjust\"</code>: use least-squares fitting for titration data given in pH, but allowing the pH to be adjusted as if its EMF<sup>0</sup> was not perfectly calibrated.</li> <li><code>\"pH_gran\"</code>: use a Gran-plot approach for titration data given in pH.</li> </ul> <code>temperature_override</code> : titration temperature <p>Must be in \u00b0C.  If not supplied, the values in the titration file are used.  Otherwise, this value overrides them.</p> <code>titrant</code> : The titrant being used <p>Use <code>\"HCl\"</code> (default) for hydrochloric acid or <code>\"H2SO4\"</code> for sulfuric acid.</p> <code>titrant_amount_unit</code> : unit for the amount of titrant in the titration file <p>Either <code>\"ml\"</code> (default) for volume in ml or <code>\"g\"</code> / <code>\"kg\"</code> for mass in g / kg.</p> <p>If volume is provided, then if <code>titrant=\"HCl\"</code> or by default, it is converted into mass following DSC07, assuming the acid contains 0.6\u00a0M NaCl and 0.1\u00a0M HCl and is at 25 \u00b0C.  If you used a different ratio, use the columns <code>molinity_NaCl</code> and <code>molinity_HCl</code> to set this.</p> <p>If you used <code>titrant=\"H2SO4\"</code>, then titrant density is calculated at 25 \u00b0C following a basic parameterisation of E-AIM results against molinity.</p> <p>Regardless of the <code>titrant</code>, these density equations can also be overwritten with a specific value in the <code>titrant_density</code> column.</p> <code>titrant_density</code> : density of the titrant <p>Titrant density in kg/dm<sup>3</sup>.  If provided, this is used only when <code>titrant_amount_unit=\"ml\"</code>, and it takes precedence over density calculated from the equations described in that section.</p> <code>titrant_molinity</code> : molinity of the titrant <p>Must be in mol/kg-sol.</p>"},{"location":"methods/","title":"Dataset methods","text":"<p>Once you have imported your Dataset (as <code>ds</code> in the example code below) and made sure it has the necessary columns, named correctly, you can use a series of different functions or methods to calibrate the titrant and solve the samples for alkalinity.</p> <p>Methods or functions?</p> <p>All the methods mentioned here operate on the Dataset in-place, but are also available as functions at the top-level, in case you prefer that syntax.  The method approach is recommended:</p> <pre><code>ds.calkulate()\n</code></pre> <p>But you could also achieve the same thing with the function approach, if you prefer:</p> <pre><code>ds = calk.calkulate(ds)\n</code></pre>"},{"location":"methods/#do-everything-at-once-with-calkulate","title":"Do everything at once with <code>calkulate</code>...","text":"<p>The method <code>calkulate</code> does everything:</p> <pre><code>ds.calkulate()\n</code></pre>"},{"location":"methods/#or-do-it-step-by-step","title":"... or do it step-by-step","text":"<p>But what do we mean by everything?  This includes two main steps: calibration and solving.  You can also run yourself separately if you prefer.</p>"},{"location":"methods/#calibrate-titrant-molinity","title":"Calibrate titrant molinity","text":"<pre><code>ds.calibrate()\n</code></pre> <p>For each titration (i.e. row in the Dataset) that has an <code>alkalinity_certified</code> value, this method determines the titrant molinity (in mol/kg-sol) that is required for the titration to return its certified alkalinity value.  This is stored in a new column in the Dataset called <code>titrant_molinity_here</code>.</p> <p>Then, the <code>titrant_molinity_here</code> values are averaged \u2014 by <code>analysis_batch</code> if provided, or over the entire Dataset if not \u2014 and stored in a new column called <code>titrant_molinity</code>.</p>"},{"location":"methods/#solve-samples-for-alkalinity","title":"Solve samples for alkalinity","text":"<pre><code>ds.solve()\n</code></pre> <p>For each titration (i.e. row in the Dataset) that has an <code>titrant_molinity</code> value (e.g. as generated by <code>ds.calibrate()</code> above), this method determines its total alkalinity in \u00b5mol/kg-sol.  The results are stored in a new column in the Dataset called <code>alkalinity</code>.</p>"},{"location":"methods/#why-break-it-up","title":"Why break it up?","text":"<p>You may wish to use the step-by-step approach if you need to do any intermediate processing.  For example, if the approach of taking the mean titrant molinity for each analysis batch is not appropriate to your dataset, you could do:</p> <pre><code>import calkulate as calk\n\n# Import data and calibrate individual titrant molinities\nds = calk.read_excel(\"path/to/metadata_file.xlsx\").calibrate()\n\n# Update the titrant molinity values to whatever they should be\nds[\"titrant_molinity\"] = ...\n\n# Solve for alkalinity\nds.solve()\n</code></pre> <p>Alternatively, if your metadata is coming from a VINDTA dbs file, you may need to add extra columns to it before processing:</p> <pre><code># Import metadata\nds = calk.read_dbs(\"path/to/metadata_file.dbs\")\n\n# Add extra columns\nds[\"analysis_batch\"] = ...\nds[\"alkalinity_certified\"] = ...\n# etc.\n\n# Calkulate!\nds.calkulate()\n</code></pre>"},{"location":"plot/","title":"Visualising the results","text":"<p>After running <code>calkulate()</code> (or <code>calibrate()</code> and <code>solve()</code>) on your data, Calkulate contains some plotting functions to help visualise the results.  More will be added in time, and contributions are welcome!</p>"},{"location":"plot/#dataset-plots","title":"Dataset plots","text":""},{"location":"plot/#calibrated-titrant_molinity","title":"Calibrated <code>titrant_molinity</code>","text":"<pre><code>fig, ax = calk.plot.titrant_molinity(\n    ds, xvar=None, show_bad=True, show_batches=True, figure_fname=None,\n)\n</code></pre> <p>The required argument <code>ds</code> is the metadata table as a pandas DataFrame or Calkulate Dataset.</p> <p>Optional inputs:</p> <ul> <li><code>xvar</code>: name of column to use as the x-axis variable.</li> <li><code>show_bad</code>: whether or not to show values where <code>ds.reference_good == False</code>.</li> <li><code>show_batches</code>: whether or not to show batch-averaged <code>titrant_molinity</code> values.</li> <li><code>figure_fname</code>: if provided, save figure to this filename.</li> </ul>"},{"location":"plot/#measured-certified-alkalinity_offset","title":"Measured \u2212 certified <code>alkalinity_offset</code>","text":"<pre><code>fig, ax = calk.plot.alkalinity_offset(\n    ds, xvar=None, show_bad=True, show_batches=True, figure_fname=None,\n)\n</code></pre> <p>The required argument <code>ds</code> is the metadata table as a pandas DataFrame or Calkulate Dataset.</p> <p>Optional inputs:</p> <ul> <li><code>xvar</code>: name of column to use as the x-axis variable.</li> <li><code>show_bad</code>: whether or not to show values where <code>ds.reference_good == False</code>.</li> <li><code>show_batches</code>: whether or not to show batch-averaged <code>titrant_molinity</code> values.</li> <li><code>figure_fname</code>: if provided, save figure to this filename.</li> </ul>"},{"location":"plot/#titration-plots","title":"Titration plots","text":"<p>To investigate an individual titration in more detail, first generate a <code>Titration</code> from the relevant row of your <code>Dataset</code>:</p> <pre><code>tt = ds.to_Titration(index)\n</code></pre> <p>where <code>index</code> is the index value for the row you are interested in.</p> <p>A series of figures can then be plotted for the titration in question:</p> <ul> <li><code>tt.plot_emf()</code>: how EMF changes through the titration.</li> <li><code>tt.plot_pH()</code>: how pH changes through the titration.</li> <li><code>tt.plot_gran_alkalinity()</code>: the Gran-plot initial alkalinity estimate.</li> <li><code>tt.plot_gran_emf0()</code>: the Gran-plot initial EMF<sup>0</sup> estimate.</li> <li><code>tt.plot_alkalinity()</code>: the total alkalinity calculated from each titration data point.</li> <li><code>tt.plot_components()</code>: how every equilibrating component of the solution changes throughout the titration.</li> </ul>"},{"location":"read/","title":"Importing data to Calkulate","text":"<p>All the code snippets below assume the import convention:</p> <pre><code>import calkulate as calk\n</code></pre>"},{"location":"read/#titration-metadata-dataset","title":"Titration metadata Dataset","text":"<p>Calkulate works by adding extra functions that can be used on a standard pandas DataFrame.  It also provides an optional Dataset class which adds these functions as additional methods to a DataFrame.  A Dataset contains the metadata for any number of separate titrations.</p>"},{"location":"read/#convert-from-a-dataframe","title":"Convert from a DataFrame","text":"<p>If your titration metadata is already imported as a DataFrame, you can directly convert it into a Dataset:</p> <pre><code>ds = calk.Dataset(ds)\n</code></pre>"},{"location":"read/#import-from-excel-csv-or-dbs","title":"Import from Excel, CSV or dbs","text":"<p>Or if your titration metadata is in an Excel spreadsheet, a CSV file, or another format that can be imported with pandas, you can import these with the appropriate function from below:</p> <pre><code>ds = calk.read_csv(\"path/to/metadata_file.csv\", **read_csv_kwargs)\nds = calk.read_excel(\"path/to/metadata_file.xlsx\", **read_excel_kwargs)\nds = calk.read_fwf(\"path/to/metadata_file.txt\", **read_fwf_kwargs)\nds = calk.read_table(\"path/to/metadata_file.txt\", **read_table_kwargs)\n</code></pre> <p>These are all light wrappers around the pandas functions of the same names.  You can add any kwargs needed by the pandas functions and they will be passed on too.</p> <p>If you have a VINDTA-generated .dbs file, you can import this too:</p> <pre><code>ds = calk.read_dbs(\"path/to/medatadata_file.dbs\")\n</code></pre> <p><code>read_dbs</code> also renames several columns from their defaults to the names expected by Calkulate, parses analysis dates and times, and predicts the file names based on the data in the file.</p> <p><code>read_dbs</code> kwargs</p> <ul> <li><code>filename_format</code>: <code>read_dbs</code> assumes that the .dat filenames have the format <code>\"{s}-{c}  {n}  ({d}){b}.dat\"</code>, where <code>s</code> comes from the \"station\" column in the .dbs, <code>c</code> from \"cast\", <code>n</code> from \"niskin\", <code>d</code> from \"depth\" and <code>b</code> from \"bottle\".  If the format is different, provide the correct format here.</li> </ul> <p>The columns in the Dataset must be named in a specific way for Calkulate to be able to use their data.</p>"},{"location":"read/#individual-titration-data-files","title":"Individual titration data files","text":"<p>You don't need to manually import titration data files, but you should check that their format is consistent with what Calkulate expects, and work out what extra arguments you'll need to pass if not.</p>"},{"location":"read/#the-information-they-contain","title":"The information they contain","text":"<p>Each titration file is a text file containing the measurements of the solution carried out during a titration.  The file should contain data in columns, where each row represents a measurement after a separate titrant addition.  There must be at least three columns:</p> <ol> <li>The amount of titrant added to the analyte in ml or g.</li> <li>The EMF measured across the titrant-analyte mixture in mV.</li> <li>The temperature of the titrant-analyte mixture in \u00b0C.</li> </ol>"},{"location":"read/#their-default-format","title":"Their default format","text":"<p>By default, Calkulate expects that:</p> <ul> <li>There are two lines at the start of the file to be ignored before the data columns described above begin.</li> <li>The columns appear next, in the order given (from left to right).</li> <li>The columns are tab-delimited.</li> <li>Nothing comes after the columns of titration data in the file.</li> </ul> <p>For example, a file could contain the following:</p> <pre><code>This first line is ignored.\nThis second line is also ignored.\n0.00    183.1   25.2\n0.50    225.4   25.1\n1.00    290.3   25.0\n1.50    343.4   25.1\n</code></pre> <p>If your files look like the above (e.g. they were generated by a VINDTA), then you don't need to read any further on this page.</p>"},{"location":"read/#other-formats","title":"Other formats","text":"<p>Alternatively, you may have files in a different format, for example generated directly by a Metrohm Titrino unit.  These .txt files typically have names beginning with PC_LIMS_Report_ and the titration data is found in six columns somewhere in the middle of the file.  These files can be imported by Calkulate too: when you run the <code>calibrate</code>, <code>solve</code> or <code>calkulate</code> functions, you just need to include <code>file_type=\"pclims\"</code> as a kwarg (or if using the dataset approach, add a <code>file_type</code> column to your metadata table).</p> <p>If your titration data files arrive in some other format, it's quite straightforward to add a new <code>file_type</code> option that will allow them to be imported directly.  If this applies to you, please just create an Issue on the GitHub repo, attaching an example of the file you need to import.</p>"},{"location":"references/","title":"References","text":"<p>Click on each reference to see the full citation.</p>"},{"location":"references/#d","title":"D","text":"D81: Dickson (1981) Deep-Sea Res. Pt A <p>Dickson, A. G. (1981).  An exact definition of total alkalinity and a procedure for the estimation of alkalinity and total inorganic carbon from titration data.  Deep Sea Research Part A. Oceanographic Research Papers 28(6), 609\u2013623.  doi:10.1016/0198-0149(81)90121-7.</p> DAA03: Dickson et al. (2003) Mar. Chem. <p>Dickson, A. G., Afghan, J. D., and Anderson, G. C. (2003).  Reference materials for oceanic CO<sub>2</sub> analysis: a method for the certification of total alkalinity.  Marine Chemistry 80(2\u20133), 185\u2013197.  doi:10.1016/S0304-4203(02)00133-0.</p> DSC07: Dickson et al. (2007) 'Guide to Best Practices...' <p>Dickson, A. G., Sabine, C. L., and Christian, J. R. eds. (2007). Guide to Best Practices for Ocean CO<sub>2</sub> Measurements. PICES Special Publication 3.</p>"},{"location":"references/#h","title":"H","text":"H15: Humphreys (2015) PhD thesis <p>Humphreys, M. P. (2015).  \"Calculating seawater total alkalinity from open-cell titration data using a modified Gran plot technique,\" in Measurements and Concepts in Marine Carbonate Chemistry (PhD Thesis, Ocean and Earth Science, University of Southampton, UK), 25\u201344.</p> HLSP22: Humphreys et al. (2022) Geosci. Model Dev. <p>Humphreys, M. P., Lewis, E. R., Sharp, J. D., and Pierrot, D. (2021).  PyCO2SYS v1.8: marine carbonate system calculations in Python.  Geoscientific Model Development 15, 15\u201343.  doi:10.5194/gmd-15-15-2022.</p> HSS22: Humphreys et al. (2022) \"PyCO2SYS: marine carbonate...\" <p>Humphreys, M. P., Schiller, A. J., Sandborn, D. E., Gregor, L., Pierrot, D., van Heuven, S. M. A. C., Lewis, E. R., and Wallace, D. W. R. (2022). PyCO2SYS: marine carbonate system calculations in Python.  Zenodo. doi:10.5281/zenodo.3744275.</p>"},{"location":"references/#m","title":"M","text":"MP81: Millero &amp; Poisson (1981) Deep-Sea Res. Pt. A <p>Millero, F. J., and Poisson, A. (1981).  International one-atmosphere equation of state of seawater.  Deep-Sea Research Part A 28(6), 625\u2013629.  doi:10.1016/0198-0149(81)90122-9</p>"},{"location":"validate/","title":"Validating Calkulate","text":""},{"location":"validate/#automatic-tests","title":"Automatic tests","text":"<p>Several of the automatic tests include checks on whether Calkulate does self-consistent calibrations, for example solving a sample where the titrant was calibrated with itself, which should return exactly the correct alkalinity.</p> <p>So if the Tests badge below says \"passing\":</p> <p></p> <p>then these validation checks are working for the currently released version.</p>"},{"location":"validate/#pyco2sys-calculations","title":"PyCO2SYS calculations","text":"<p>All of the equilibrium constants and salt concentrations estimated from salinity are determined with PyCO2SYS v1.8.1 and therefore guaranteed to be identical to the values used there.  See the peer-reviewed PyCO2SYS paper and its validation docs for more information on how these themselves are validated.</p>"},{"location":"versions/","title":"Version history","text":""},{"location":"versions/#version-23-best-of-v2-and-v3","title":"Version 23: best of v2 and v3","text":"<p>Calkulate v3 went too far overboard with the OO approach and ended up being very slow and too complicated behind the scenes as a result.  Calkulate v23 therefore mashes together the best bits of v2 and v3 for the ultimate alkalinity solving experience.</p>"},{"location":"versions/#237-1-july-2025","title":"23.7 (1 July 2025)","text":"<p>Different results in v23.7</p> <p>A few default settings changed in v23.7, which means that calculated results will be slightly different.  Changes should be at most on the order of 1 \u00b5mol/kg, and the new results should be more accurate.</p> <p>To revert to the old behaviours, use the following kwargs or metadata table columns: <code>dilute_totals_for_ks=True, double=False, gran_logic=\"legacy\"</code>.</p> <p>Changes in v23.7</p> <ul> <li>All EMF solvers now do a double-solve by default, in order to improve the range of pH data that are used.  This does mean that results may change as a different set of data points will sometimes be used to solve each titration.  To revert to the old behaviour, use <code>double=False</code>.</li> <li>Equilibrium constants now vary through titrations with temperature only, not also with changing total sulfate and fluoride concentrations as in previous versions.  To revert to the old behaviour, use <code>dilute_totals_for_ks=True</code>.</li> <li>More points used for the Gran-plot initial estimate of alkalinity and EMF<sup>0</sup>.  To revert to the old behaviour, use <code>gran_logic=\"legacy\"</code>.</li> <li><code>pH_range</code> kwarg replaced with separate <code>pH_min</code> and <code>pH_max</code> kwargs, which can also be used as metadata table columns.</li> <li>Added support for VINDTA .dbs files where the CRM button was used to run reference materials.</li> <li>Added support for German-language Tiamo titration files (use <code>file_type=\"tiamo_de\"</code>).</li> <li>Major revisions to streamline the backend processing.</li> </ul>"},{"location":"versions/#236-19-february-2024","title":"23.6 (19 February 2024)","text":"<p>Changes in v23.6</p> <ul> <li>Added missing components to titration table in a <code>Titration</code>.</li> </ul> <p>v23.6.2 changes (29 October 2024)</p> <ul> <li>Fix <code>FutureWarning</code> in <code>calk.dataset.get_total_salts</code>.</li> </ul> <p>v23.6.1 changes (20 April 2024)</p> <ul> <li>Removed excessive <code>print</code> statements from debugging.</li> </ul>"},{"location":"versions/#235-4-july-2023","title":"23.5 (4 July 2023)","text":"<p>Changes in v23.5</p> <ul> <li>Added <code>to_pandas</code> method to <code>Dataset</code> for a more convenient downgrade to a pandas <code>DataFrame</code>.</li> <li>Improved docstrings for several key functions and classes.</li> <li>Fixed bugs in logicals in various <code>calk.dataset</code> functions which had meant that NaN values in the metadata file were not always being ignored.</li> <li>Fixed bug in the <code>Dataset.solve</code> method such that the <code>analyte_mass</code> is now automatically calculated from <code>analyte_volume</code>.</li> <li>Switched to using pyproject.toml instead of setup.py for building the package.</li> <li>Renamed module <code>io</code> as <code>read</code>.</li> </ul>"},{"location":"versions/#234-13-june-2023","title":"23.4 (13 June 2023)","text":"<p>Changes in v23.4</p> <ul> <li>Swapped deprecated pandas <code>.iteritems</code> for <code>.items</code>.</li> <li>Improvements to <code>Titration</code> class.</li> </ul>"},{"location":"versions/#233-22-june-2022","title":"23.3 (22 June 2022)","text":"<p>Changes in v23.3</p> <ul> <li>Added a test of the DSC07 SOP 3b example dataset.</li> <li>Updated for compatibility with PyCO2SYS v1.8.1 (but no longer with v1.8.0).</li> </ul>"},{"location":"versions/#232","title":"23.2","text":"<p>Adds <code>Titration</code> class for investigating single titrations.</p>"},{"location":"versions/#2322-4-february-2022","title":"23.2.2 (4 February 2022)","text":"<p>Changes in v23.2.2</p> <ul> <li>More properties calculated during titrations.</li> </ul>"},{"location":"versions/#2321-13-august-2021","title":"23.2.1 (13 August 2021)","text":"<p>Changes in v23.2.1</p> <ul> <li>Solver functions return additional diagnostic information about each titration.</li> </ul>"},{"location":"versions/#2320-6-july-2021","title":"23.2.0 (6 July 2021)","text":"<p>Changes in v23.2.0</p> <ul> <li>Adds (as yet undocumented) <code>Titration</code> class for investigating single titrations.</li> <li>Adds (as yet undocumented) plotting functions for <code>Titration</code> objects.</li> </ul>"},{"location":"versions/#231","title":"23.1","text":"<p>Adds solvers for titrations with an H<sub>2</sub>SO<sub>4</sub> titrant.</p>"},{"location":"versions/#2311-7-june-2021","title":"23.1.1 (7 June 2021)","text":"<p>Changes in v23.1.1</p> <ul> <li>Now compatible with PyCO2SYS v1.7.0.</li> </ul>"},{"location":"versions/#2310-29-march-2021","title":"23.1.0 (29 March 2021)","text":"<p>Changes in v23.1.0</p> <ul> <li>Adds solvers for titrations with an H<sub>2</sub>SO<sub>4</sub> titrant (see optional <code>titrant</code> column in the metadata contents).</li> <li>Adds optional <code>titrant_density</code> column to overwrite the internally calculated titrant density with a user-specified value.</li> </ul>"},{"location":"versions/#230","title":"23.0","text":""},{"location":"versions/#2302-15-march-2021","title":"23.0.2 (15 March 2021)","text":"<p>Changes in v23.0.2</p> <ul> <li>Better handling of missing dates in files imported with <code>read_dbs</code>.</li> <li>Minor adjustments and bug fixes in a few internal functions.</li> </ul>"},{"location":"versions/#2301-25-february-2021","title":"23.0.1 (25 February 2021)","text":"<p>Changes in v23.0.1</p> <ul> <li>Print more informative error messages when titration data files cannot be found.</li> <li>Use <code>read_dat_genfromtxt</code> by default if <code>read_dat_method</code> not recognised, instead of throwing an error.</li> </ul>"},{"location":"versions/#2300-22-february-2021","title":"23.0.0 (22 February 2021)","text":"<p>Introduction of v23.0.0</p> <ul> <li>Object-oriented syntax from v3 is available to quickly work with datasets of many titrations at once.</li> <li>Underlying functions work much faster with raw NumPy arrays as in v2.</li> <li>Some basic plotting functions added.</li> </ul>"},{"location":"versions/#version-3-poorly-pythonic","title":"Version 3: poorly Pythonic","text":"<p>Calkulate v3 switches to an object-oriented approach.  This makes working with individual titrations and handling large collections of them much less cumbersome.</p> <p>PyCO2SYS is now used to determine equilibrium constants and estimate total salt concentrations from salinity, instead of replicating those functions in Calkulate.</p>"},{"location":"versions/#31","title":"3.1","text":""},{"location":"versions/#310-27-october-2020","title":"3.1.0 (27 October 2020)","text":"<p>Changes in v3.1.0</p> <p>Major bug fix</p> <ul> <li>Fixed unit conversion bug when evaluating equilibrium constants in PyCO2SYS.  All results calculated using v3.0.X should be redetermined!</li> </ul> <p>Better consistency with PyCO2SYS</p> <ul> <li>Updated for compatability with PyCO2SYS v1.6.0.</li> <li>Added two optional extra alkalinity components.</li> <li>Renamed various internal variables for better consistency.</li> </ul>"},{"location":"versions/#30","title":"3.0","text":""},{"location":"versions/#301-23-september-2020","title":"3.0.1 (23 September 2020)","text":"<p>Changes in v3.0.1</p> <p>Bug fixes</p> <ul> <li>Fix bug in handling <code>data[\"file_good\"] = False</code> cases.</li> <li>Set DIC to zero where its value is NaN.</li> <li>Skip over errors in titration files with a warning rather than throw a breaking error.</li> </ul>"},{"location":"versions/#300-15-september-2020","title":"3.0.0 (15 September 2020)","text":"<p>Release notes for v3.0.0</p> <ul> <li>Introduces object-oriented approach in which most Calkulate functions are extensions to pandas DataFrames.</li> <li>Uses PyCO2SYS to evaluate all equilibrium constants and salt concentrations from salinity and temperature.</li> </ul>"},{"location":"versions/#version-2-python","title":"Version 2: Python","text":"<p>Calkulate v2 transitioned from MATLAB to Python and added several additional alkalinity solvers.  Despite being implemented in Python, the style was still rather MATLAB-esque.</p>"},{"location":"versions/#version-1-matlab","title":"Version 1: MATLAB","text":"<p>The original Calkulate v1 was a MATLAB implementation of the \"half-Gran\" alkalinity solver described by H15. The final version (v1.0.2) remains freely available.</p>"}]}