# Dataset methods

Once you have [imported your Dataset](../io/#titration-metadata-dataset) (as `ds` in the example code below) and made sure it has [the necessary columns, named correctly](../metadata/#dataset-column-names), you can use a series of different functions or methods to calibrate the titrant and solve the samples for alkalinity.

!!! question "Methods or functions?"

    All the methods mentioned here operate on the Dataset in-place, but are also available as functions at the top-level, in case you prefer that syntax.  The method approach is recommended:

    ```python
    ds.calkulate()
    ```

    But you could also achieve the same thing with the function approach, if you prefer:

    ```
    ds = calk.calkulate(ds)
    ```

## Do everything at once with `calkulate`...

The method `calkulate` does *everything:*

```python
ds.calkulate()
```

## ... or do it step-by-step

But what do we mean by *everything?*  This includes two main steps: calibration and solving.  You can also run yourself separately if you prefer.

### Calibrate titrant molinity

```python
ds.calibrate()
```

For each titration (i.e. row in the Dataset) that has an [`alkalinity_certified` value](../metadata/#recommended-columns), this method determines the titrant molinity (in mol/kg-solution) that is required for the titration to return its certified alkalinity value.  This is stored in a new column in the Dataset called `titrant_molinity_here`.

Then, the `titrant_molinity_here` values are averaged — [by `analysis_batch`](../metadata/#recommended-columns) if provided, or over the entire Dataset if not — and stored in a new column called `titrant_molinity`.

### Solve samples for alkalinity

```python
ds.solve()
```

For each titration (i.e. row in the Dataset) that has an `titrant_molinity` value (e.g. as generated by `ds.calibrate()` above), this method determines its total alkalinity in μmol/kg-solution.  The results are stored in a new column in the Dataset called `alkalinity`.

## Why break it up?

You may wish to use the step-by-step approach if you need to do any intermediate processing.  For example, if the approach of taking the mean titrant molinity for each analysis batch is not appropriate to your dataset, you could do:

```python
import calkulate as calk

# Import data and calibrate individual titrant molinities
ds = calk.read_excel("path/to/metadata_file.xlsx").calibrate()

# Update the titrant molinity values to whatever they should be
ds["titrant_molinity"] = ...

# Solve for alkalinity
ds.solve()
```

Alternatively, if your metadata is coming from a VINDTA dbs file, you may need to add extra columns to it before processing:

```python
# Import metadata
ds = calk.read_dbs("path/to/metadata_file.dbs")

# Add extra columns
ds["analysis_batch"] = ...
ds["alkalinity_certified"] = ...
# etc.

# Calkulate!
ds.calkulate()
```
